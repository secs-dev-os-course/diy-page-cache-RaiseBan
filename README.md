### Отчет по лабораторной работе №2  
**Тема:** Реализация блочного кеша в пространстве пользователя  
**Студент:** Шорников Сергей Андреевич  
**Группа:** P3311  
**Преподаватель:** Осипов Святослав Владимирович 
**Вариант:** ОС: Windows; Политика вытеснения: LFU  

---

## **Текст задания**  
**Цель:**  
Разработать блочный кеш в пространстве пользователя в виде динамической библиотеки (DLL) с заданной политикой вытеснения (например, LFU) для оптимизации работы с блочными устройствами.  

**Описание задания:**  
1. Реализовать простой API для работы с файлами:
   - `int lab2_open(const char* path);`
   - `int lab2_close(int fd);`
   - `ssize_t lab2_read(int fd, void* buf, size_t count);`
   - `ssize_t lab2_write(int fd, const void* buf, size_t count);`
   - `off_t lab2_lseek(int fd, off_t offset, int whence);`
   - `int lab2_fsync(int fd);`
2. Операции чтения и записи должны выполняться в обход системного page cache.
3. Адаптировать программу-нагрузчик из ЛР1 для проверки работоспособности блочного кеша.
4. Сравнить производительность с использованием блочного кеша и без него.

---

## **Краткий обзор кода**

### **Основная структура программы**
1. **Динамическая библиотека:**
   - Реализована библиотека `lab2` с API для работы с файлами.  
   - Все операции кеширования реализуются через класс `CacheManager`.

2. **Ключевые компоненты:**
   - **`CacheBlock`:** Структура для хранения данных блока, состояния "грязный/чистый" и частоты доступа.
   - **`CacheManager`:** Управляет кешем, хранит таблицу открытых файлов (`open_files_`) и блоков в кеше (`cache_map_`). Реализует алгоритм LFU для вытеснения.

3. **API:**
   - Функции чтения и записи:
     - `lab2_read` и `lab2_write` проверяют наличие блоков в кеше через `getCacheBlock` и обновляют их содержимое.
   - Сброс данных на диск:
     - `lab2_fsync` вызывает `flushFile`, записывая "грязные" блоки на диск.
   - Управление файловыми дескрипторами:
     - `lab2_open` и `lab2_close` взаимодействуют с файловой системой.

4. **Особенности реализации:**
   - Размер блока фиксирован: `4 KB`.
   - Политика вытеснения: **LFU** (Least Frequently Used).
   - Используется `std::unordered_map` для хранения блоков кеша.

---

## **Данные о работе программы-нагрузчика**

### **Условия эксперимента**
1. **Тестовая программа:** Выполняет сортировку массива чисел с использованием алгоритма Quick Sort по внешней памяти.
2. **Файл:** `random_numbers.bin`, размер ~1 ГБ.

---

### **Результаты эксперимента**

| Режим работы                 | Время выполнения (сек.) | Cache Hit Rate (%) |
|------------------------------|--------------------------|---------------------|
| **Системный кеш** (без DLL)  | 73.54                   | -                   |
| **Блочный кеш** (с DLL)      | 92.82                   | 82.4                |

---

## **Заключение**

1. **Анализ результатов:**
   - **Производительность:** При использовании блочного кеша время выполнения увеличилось примерно на **26%** по сравнению с использованием системного кеша.
   - **Основные причины увеличения времени:**
     - Накладные расходы на управление кешем в пользовательском пространстве.
     - Алгоритм LFU требует частого обновления счётчиков доступа, что замедляет операции при большом объёме данных.
     - Фиксированный размер блока (4 КБ) привёл к большому количеству кеш-промахов при работе с файлом объёмом 1 ГБ.
   - **Преимущество:** Cache Hit Rate составил **82.4%**, что демонстрирует, что значительная часть запросов обслуживалась из кеша.




**Вывод:**  
Реализация блочного кеша показала корректную работу, но уступает системному кешу по производительности.
