### Отчет по лабораторной работе №2  
**Тема:** Реализация блочного кеша в пространстве пользователя  
**Студент:** Шорников Сергей Андреевич  
**Группа:** P3311  
**Преподаватель:** Осипов Святослав Владимирович 
**Вариант:** ОС: Windows; Политика вытеснения: LFU  

---

## **Текст задания**  
**Цель:**  
Разработать блочный кеш в пространстве пользователя в виде динамической библиотеки (DLL) с заданной политикой вытеснения (например, LFU) для оптимизации работы с блочными устройствами.  

**Описание задания:**  
1. Реализовать простой API для работы с файлами:
   - `int lab2_open(const char* path);`
   - `int lab2_close(int fd);`
   - `ssize_t lab2_read(int fd, void* buf, size_t count);`
   - `ssize_t lab2_write(int fd, const void* buf, size_t count);`
   - `off_t lab2_lseek(int fd, off_t offset, int whence);`
   - `int lab2_fsync(int fd);`
2. Операции чтения и записи должны выполняться в обход системного page cache.
3. Адаптировать программу-нагрузчик из ЛР1 для проверки работоспособности блочного кеша.
4. Сравнить производительность с использованием блочного кеша и без него.

---

## **Краткий обзор кода**

### **Основная структура программы**
1. **Динамическая библиотека:**
   - Реализована библиотека `lab2` с API для работы с файлами.  
   - Все операции кеширования реализуются через класс `CacheManager`.

2. **Ключевые компоненты:**
   - **`CacheBlock`:** Структура для хранения данных блока, состояния "грязный/чистый" и частоты доступа.
   - **`CacheManager`:** Управляет кешем, хранит таблицу открытых файлов (`open_files_`) и блоков в кеше (`cache_map_`). Реализует алгоритм LFU для вытеснения.

3. **API:**
   - Функции чтения и записи:
     - `lab2_read` и `lab2_write` проверяют наличие блоков в кеше через `getCacheBlock` и обновляют их содержимое.
   - Сброс данных на диск:
     - `lab2_fsync` вызывает `flushFile`, записывая "грязные" блоки на диск.
   - Управление файловыми дескрипторами:
     - `lab2_open` и `lab2_close` взаимодействуют с файловой системой.

4. **Особенности реализации:**
   - Размер блока фиксирован: `4 KB`.
   - Политика вытеснения: **LFU** (Least Frequently Used).
   - Используется `std::unordered_map` для хранения блоков кеша.

---

## **Данные о работе программы-нагрузчика**

### **Условия эксперимента**
1. **Тестовая программа:** Ищет подстроку в большом файле.
2. **Файл:** `random_letters.txt`, размер ~4 Кб.
3. **Количество итераций:** 10,000 запросов.

---

### **Результаты эксперимента**

| Режим работы                 | Количество вхождений | Время выполнения (сек.) |
|------------------------------|----------------------|--------------------------|
| **Системный кеш** (без DLL)  | 10,000              | 2.6936                  |
| **Блочный кеш** (с DLL)      | 10,000              | 5.5761                  |

---

## **Заключение**

1. **Анализ результатов:**
   - Производительность блочного кеша в 2 раза ниже системного кеша.
   - Основные причины:
     - Накладные расходы на управление кешем в пространстве пользователя (поддержка структуры `cache_map_`, обновление частоты доступа).
     - Использование алгоритма LFU, требующего частых обновлений счётчиков частоты.
     - Фиксированный размер блока (4 KB) не всегда оптимален для конкретных операций.

2. **Преимущества реализации:**
   - Блочный кеш полностью контролируемый и позволяет точно задавать алгоритмы управления данными.
   - Работает независимо от системного page cache, что полезно для специфичных задач.


**Вывод:**  
Реализация блочного кеша показала корректную работу, но уступает системному кешу по производительности. Оптимизации, предложенные выше, могут улучшить результаты.
